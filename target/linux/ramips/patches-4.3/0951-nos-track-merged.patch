From 2f0270377d16f312e6ce053d6887b67f993d6f5b Mon Sep 17 00:00:00 2001
From: Chen Minqiang <ptpt52@gmail.com>
Date: Tue, 1 Mar 2016 11:36:28 +0800
Subject: [PATCH] nos track merged

---
 arch/mips/Kconfig                           |   2 +-
 arch/mips/configs/mt7621_defconfig          |   2 +-
 arch/mips/include/asm/mach-generic/spaces.h |   2 +-
 arch/mips/include/asm/mach-ralink/mt7621.h  |   2 +-
 arch/mips/kernel/setup.c                    |  49 ++++
 include/linux/nos_mempool.h                 |  62 +++++
 include/linux/nos_skb.h                     |  20 ++
 include/linux/nos_track.h                   | 158 ++++++++++++
 include/linux/skbuff.h                      |   6 +
 include/net/netfilter/nf_conntrack.h        |  16 ++
 kernel/Kconfig.hz                           |   2 +-
 kernel/Makefile                             |   2 +-
 kernel/nos_track.c                          | 374 ++++++++++++++++++++++++++++
 net/netfilter/nf_conntrack_core.c           |  40 +++
 net/netfilter/nf_conntrack_standalone.c     |   7 +
 15 files changed, 738 insertions(+), 6 deletions(-)
 create mode 100644 include/linux/nos_mempool.h
 create mode 100644 include/linux/nos_skb.h
 create mode 100755 include/linux/nos_track.h
 create mode 100755 kernel/nos_track.c

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 79b7bf6..8efe2ec 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -2535,7 +2535,7 @@ config MIPS_PERF_SHARED_TC_COUNTERS
 
 choice
 	prompt "Timer frequency"
-	default HZ_250
+	default HZ_1000
 	help
 	 Allows the configuration of the timer frequency.
 
diff --git a/arch/mips/configs/mt7621_defconfig b/arch/mips/configs/mt7621_defconfig
index 7719471..cdcc359 100644
--- a/arch/mips/configs/mt7621_defconfig
+++ b/arch/mips/configs/mt7621_defconfig
@@ -25,7 +25,7 @@ CONFIG_SCHED_SMT=y
 # CONFIG_COMPACTION is not set
 # CONFIG_CROSS_MEMORY_ATTACH is not set
 # CONFIG_SECCOMP is not set
-CONFIG_HZ_100=y
+CONFIG_HZ_1000=y
 CONFIG_CMDLINE_BOOL=y
 CONFIG_CMDLINE="rootfstype=squashfs,jffs2"
 # CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
diff --git a/arch/mips/include/asm/mach-generic/spaces.h b/arch/mips/include/asm/mach-generic/spaces.h
index 05c5224..afc96ec 100644
--- a/arch/mips/include/asm/mach-generic/spaces.h
+++ b/arch/mips/include/asm/mach-generic/spaces.h
@@ -44,7 +44,7 @@
  * Memory above this physical address will be considered highmem.
  */
 #ifndef HIGHMEM_START
-#define HIGHMEM_START		_AC(0x10000000, UL)
+#define HIGHMEM_START		_AC(0x20000000, UL)
 #endif
 
 #endif /* CONFIG_32BIT */
diff --git a/arch/mips/include/asm/mach-ralink/mt7621.h b/arch/mips/include/asm/mach-ralink/mt7621.h
index 5eca174..90d4e04 100644
--- a/arch/mips/include/asm/mach-ralink/mt7621.h
+++ b/arch/mips/include/asm/mach-ralink/mt7621.h
@@ -32,7 +32,7 @@
 
 #define MT7621_DRAM_BASE                0x0
 #define MT7621_DDR2_SIZE_MIN		32
-#define MT7621_DDR2_SIZE_MAX		256
+#define MT7621_DDR2_SIZE_MAX		512
 
 #define MT7621_CHIP_NAME0		0x3637544D
 #define MT7621_CHIP_NAME1		0x20203132
diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 75bde36..9a34642 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -133,6 +133,13 @@ void __init detect_memory_region(phys_addr_t start, phys_addr_t sz_min, phys_add
 	void *dm = &detect_magic;
 	phys_addr_t size;
 
+#if defined(CONFIG_SOC_MT7621)
+	//#warning "use mt 7621 mem auto region..."
+	phys_addr_t low_mem_size   = 0x1c000000;
+	phys_addr_t high_mem_start = 0x20000000;
+	phys_addr_t high_mem_size  = 0;
+#endif
+
 	for (size = sz_min; size < sz_max; size <<= 1) {
 		if (!memcmp(dm, dm + size, sizeof(detect_magic)))
 			break;
@@ -144,7 +151,15 @@ void __init detect_memory_region(phys_addr_t start, phys_addr_t sz_min, phys_add
 		((unsigned long long) sz_min) / SZ_1M,
 		((unsigned long long) sz_max) / SZ_1M);
 
+#if defined(CONFIG_SOC_MT7621)
+	low_mem_size = (size > low_mem_size)?low_mem_size:size;
+	high_mem_size = size - low_mem_size;
+	add_memory_region(start,low_mem_size, BOOT_MEM_RAM);
+	if(high_mem_size > 0)
+		add_memory_region(high_mem_start,high_mem_size, BOOT_MEM_RAM);
+#else
 	add_memory_region(start, size, BOOT_MEM_RAM);
+#endif
 }
 
 static void __init print_memory_map(void)
@@ -616,6 +631,38 @@ static void __init request_crashkernel(struct resource *res)
 }
 #endif /* !defined(CONFIG_KEXEC)  */
 
+/* Location of the reserved area for nos */
+struct resource nosmem_res = {
+	.name  = "NOS Memory",
+	.start = 0,
+	.end   = 0,
+	.flags = IORESOURCE_BUSY | IORESOURCE_MEM
+};
+
+static void __init reserve_nosmem(void)
+{
+	unsigned long long nosmem_size, nosmem_base;
+	int ret;
+
+	nosmem_base = 16 << 20;
+	nosmem_size = 32 << 20;
+
+	ret = reserve_bootmem(nosmem_base, nosmem_size, BOOTMEM_EXCLUSIVE);
+	if (ret < 0) {
+		printk(KERN_WARNING "NOS reservation failed - "
+		       "memory is in use (0x%lx)\n", (unsigned long)nosmem_base);
+		return;
+	}
+
+	printk(KERN_INFO "Reserving %ldMB of memory at %ldMB for NOS\n",
+	       (unsigned long)(nosmem_size >> 20),
+	       (unsigned long)(nosmem_base >> 20));
+
+	nosmem_res.start = nosmem_base;
+	nosmem_res.end = nosmem_base + nosmem_size - 1;
+	insert_resource(&iomem_resource, &nosmem_res);
+}
+
 static void __init arch_mem_init(char **cmdline_p)
 {
 	struct memblock_region *reg;
@@ -789,6 +836,8 @@ void __init setup_arch(char **cmdline_p)
 	plat_smp_setup();
 	prefill_possible_map();
 
+	reserve_nosmem();
+
 	cpu_cache_init();
 	device_tree_init();
 }
diff --git a/include/linux/nos_mempool.h b/include/linux/nos_mempool.h
new file mode 100644
index 0000000..a787e0e
--- /dev/null
+++ b/include/linux/nos_mempool.h
@@ -0,0 +1,62 @@
+#ifndef _NOS_MEMPOOL_H
+#define _NOS_MEMPOOL_H
+
+#include <linux/spinlock.h>
+#include <linux/kernel.h>
+#include <linux/ratelimit.h>
+
+struct nos_mempool {
+	spinlock_t lock;
+	void *head;
+	void **tail;
+	int nr_used;
+	int nr_free;
+	const char *name;
+};
+
+static __inline void
+nos_mempool_init(struct nos_mempool *pool, const char *name, int nr_used)
+{
+	spin_lock_init(&pool->lock);
+	pool->head = NULL;
+	pool->tail = &pool->head;
+	pool->nr_used = nr_used;
+	pool->nr_free = 0;
+	pool->name = name;
+}
+
+static __inline void *
+nos_mempool_get(struct nos_mempool *pool)
+{
+	void *data;
+
+	spin_lock_bh(&pool->lock);
+	data = pool->head;
+	if (data != NULL) {
+		pool->head = *(void **)data;
+		if (pool->head == NULL) {
+			pool->tail = &pool->head;
+		}
+		pool->nr_used++;
+		pool->nr_free--;
+	} else {
+		pr_warn_ratelimited("nos_mempool oom: %s, nr_used: %d, nr_free: %d\n",
+							pool->name, pool->nr_used, pool->nr_free);
+	}
+	spin_unlock_bh(&pool->lock);
+	return data;
+}
+
+static __inline void
+nos_mempool_put(struct nos_mempool *pool, void *data)
+{
+	spin_lock_bh(&pool->lock);
+	*(void **)data = NULL;
+	*pool->tail = data;
+	pool->tail = (void **)data;
+	pool->nr_used--;
+	pool->nr_free++;
+	spin_unlock_bh(&pool->lock);
+}
+
+#endif /* _NOS_MEMPOOL_H */
diff --git a/include/linux/nos_skb.h b/include/linux/nos_skb.h
new file mode 100644
index 0000000..08f3688
--- /dev/null
+++ b/include/linux/nos_skb.h
@@ -0,0 +1,20 @@
+#ifndef __NOS_SKB_H__
+#define __NOS_SKB_H__
+
+#include <linux/types.h>
+#include <linux/if.h>
+
+#define NOS_QOS_LINE_MAX 	(8)
+
+struct tbq_packet_ctrl {
+	struct tbq_bucket_sched *bucket_sched;
+	struct tbq_user_sched *user_sched;
+	uint32_t rule_mask;
+	uint32_t pkt_len;
+};
+
+struct nos_skb_info {
+	struct tbq_packet_ctrl pc;
+};
+
+#endif	//__NOS_SKB_H__
\ No newline at end of file
diff --git a/include/linux/nos_track.h b/include/linux/nos_track.h
new file mode 100755
index 0000000..92b0b00
--- /dev/null
+++ b/include/linux/nos_track.h
@@ -0,0 +1,158 @@
+#ifndef _NOS_TRACK_H
+#define _NOS_TRACK_H
+
+#include <linux/types.h>
+
+#define NOS_USER_TRACK_MAX 			(1 << 19 >> 3)
+#define NOS_FLOW_TRACK_MAX 			(1 << 18 >> 3)
+
+#define NOS_USER_INFO_SIZE			(256)
+#define NOS_FLOW_INFO_SIZE			(256)
+
+#define NOS_USER_DATA_SIZE (NOS_USER_INFO_SIZE - 16)
+#define NOS_FLOW_DATA_SIZE (NOS_FLOW_INFO_SIZE - sizeof(struct nos_flow_tuple) - 16)
+
+#define NOS_FLOW_DIR_UNKNOWN		(0)
+#define NOS_FLOW_DIR_LAN2WAN		(1)
+#define NOS_FLOW_DIR_WAN2LAN		(2)
+#define NOS_FLOW_DIR_LAN2LAN		(3)
+#define NOS_FLOW_DIR_WAN2WAN		(4)
+
+struct nos_flow_tuple {
+	uint32_t ip_src;
+	uint32_t ip_dst;
+	uint16_t port_src;
+	uint16_t port_dst;
+	uint8_t  proto;
+	uint8_t  dir; 	//wan->lan, lan->wan, lan->lan, wan->wan.
+	uint8_t  inface;  //lan | wan.
+	uint8_t  dummy_pad;
+};
+
+struct nos_user_info {
+	uint32_t magic;
+	uint32_t id;
+	uint32_t ip;
+	uint32_t refcnt;
+
+	char data[NOS_USER_DATA_SIZE]; //data store for user define struct
+};
+
+static inline void * nos_user_info_priv(struct nos_user_info * user)
+{
+	return (void*)user->data;
+}
+
+struct nos_flow_info {
+	uint32_t magic;
+	uint32_t id;
+	uint32_t usr_src_id;
+	uint32_t usr_dst_id;
+
+	struct nos_flow_tuple tuple;
+
+	char data[NOS_FLOW_DATA_SIZE]; //data store for user define struct
+};
+
+static inline void * nos_flow_info_priv(struct nos_flow_info* flow)
+{
+	return (void*)flow->data;
+}
+
+#ifdef __KERNEL__
+
+#include <asm/atomic.h>
+#include <linux/list.h>
+#include <linux/rculist.h>
+#include <linux/spinlock.h>
+#include <linux/rbtree.h>
+
+struct tbq_backlog {
+	struct list_head list;
+	struct tbq_token_ctrl *tc;
+	uint32_t octets;
+	uint32_t weight;
+	int32_t drr_deficit;
+};
+
+struct tbq_flow_backlog {
+	struct tbq_backlog base;
+	struct list_head packets;
+	struct tbq_flow_track *tf;
+};
+
+struct tbq_flow_track {
+	struct list_head list;
+	uint16_t dummy;
+	uint16_t app_id;
+	uint32_t rule_mask;
+	uint8_t weight[32];
+	struct tbq_flow_backlog backlog[2];
+};
+
+struct nos_track {
+	struct nos_flow_info *flow;
+	struct nos_user_info *usr_src;
+	struct nos_user_info *usr_dst;
+	struct tbq_flow_track tbq;
+};
+
+struct nos_user_track {
+	uint32_t ip;
+	uint32_t magic;
+	struct hlist_node hash_node;
+	spinlock_t lock;
+	uint32_t refcnt;
+	void *tbq;
+};
+
+struct nos_flow_track {
+	uint32_t magic;
+	struct nos_user_track *usr_src;
+	struct nos_user_track *usr_dst;
+};
+
+struct nos_track_event {
+	struct list_head list;
+	void (* on_user_free)(struct nos_user_track *);
+	void (* on_flow_free)(struct tbq_flow_track *);
+};
+
+struct nos_track_stats {
+	atomic64_t nr_flow_alloc;
+	atomic64_t nr_flow_free;
+	atomic64_t nr_ring_drop;
+};
+
+extern struct nos_track_stats *nos_track_stats;
+
+int nos_track_init(void);
+int nos_track_alloc(struct nos_track *track, struct nos_flow_tuple *tuple);
+void nos_track_free(struct nos_track *track);
+
+struct nos_user_track *nos_get_user_track(struct nos_track *track);
+struct nos_flow_track *nos_get_flow_track(struct nos_track *track);
+
+void nos_track_event_register(struct nos_track_event *ev);
+void nos_track_event_unregister(struct nos_track_event *ev);
+
+/* common apis */
+static inline struct nos_flow_info* nos_get_flow_info(struct nos_track* nos)
+{
+	return nos->flow;
+}
+
+static inline struct nos_user_info* nos_get_user_info(struct nos_track* nos)
+{	
+	return nos->usr_src;
+}
+
+static inline struct nos_user_info* nos_get_peer_info(struct nos_track *nos)
+{
+	return nos->usr_dst;
+}
+
+#endif /* __KERNEL__ */
+
+
+#endif /* _NOS_TRACK_H */
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index b9b0125..d4e51a2 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -39,6 +39,9 @@
 #include <linux/in6.h>
 #include <net/flow.h>
 
+/* roy: for traffic control module */
+#include <linux/nos_skb.h>
+
 /* A. Checksumming of received packets by device.
  *
  * CHECKSUM_NONE:
@@ -699,6 +702,9 @@ struct sk_buff {
 				*data;
 	unsigned int		truesize;
 	atomic_t		users;
+
+	/* roy: nos traffic control */
+	struct nos_skb_info nos;
 };
 
 #ifdef __KERNEL__
diff --git a/include/net/netfilter/nf_conntrack.h b/include/net/netfilter/nf_conntrack.h
index e8ad468..f32f5e6 100644
--- a/include/net/netfilter/nf_conntrack.h
+++ b/include/net/netfilter/nf_conntrack.h
@@ -18,6 +18,8 @@
 #include <linux/compiler.h>
 #include <linux/atomic.h>
 
+#include <linux/nos_track.h>
+
 #include <linux/netfilter/nf_conntrack_tcp.h>
 #include <linux/netfilter/nf_conntrack_dccp.h>
 #include <linux/netfilter/nf_conntrack_sctp.h>
@@ -114,6 +116,9 @@ struct nf_conn {
 	/* Extensions */
 	struct nf_ct_ext *ext;
 
+	/* nos track node private */
+	struct nos_track nos_track;
+
 	/* Storage reserved for other modules, must be the last member */
 	union nf_conntrack_proto proto;
 };
@@ -295,6 +300,17 @@ extern unsigned int nf_conntrack_max;
 extern unsigned int nf_conntrack_hash_rnd;
 void init_nf_conntrack_hash_rnd(void);
 
+enum {
+	UGW_NET_MODE_ROUTER = 0,
+	UGW_NET_MODE_BRIDGE,
+};
+
+extern unsigned int nf_conntrack_mode;
+static inline unsigned int nf_ct_net_mode(void)
+{
+	return nf_conntrack_mode;
+}
+
 struct nf_conn *nf_ct_tmpl_alloc(struct net *net,
 				 const struct nf_conntrack_zone *zone,
 				 gfp_t flags);
diff --git a/kernel/Kconfig.hz b/kernel/Kconfig.hz
index 2a202a8..0a08a5b 100644
--- a/kernel/Kconfig.hz
+++ b/kernel/Kconfig.hz
@@ -4,7 +4,7 @@
 
 choice
 	prompt "Timer frequency"
-	default HZ_250
+	default HZ_1000
 	help
 	 Allows the configuration of the timer frequency. It is customary
 	 to have the timer interrupt run at 1000 Hz but 100 Hz may be more
diff --git a/kernel/Makefile b/kernel/Makefile
index e1b7438..71a6574 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -9,7 +9,7 @@ obj-y     = fork.o exec_domain.o panic.o \
 	    extable.o params.o \
 	    kthread.o sys_ni.o nsproxy.o \
 	    notifier.o ksysfs.o cred.o reboot.o \
-	    async.o range.o smpboot.o
+	    async.o range.o smpboot.o nos_track.o
 
 obj-$(CONFIG_MULTIUSER) += groups.o
 
diff --git a/kernel/nos_track.c b/kernel/nos_track.c
new file mode 100755
index 0000000..78f32ec
--- /dev/null
+++ b/kernel/nos_track.c
@@ -0,0 +1,374 @@
+#include <linux/nos_track.h>
+#include <linux/nos_mempool.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+
+#define NOS_USER_TRACK_HASH_SIZE 	NOS_USER_TRACK_MAX
+
+
+struct nos_track_stats *nos_track_stats;
+EXPORT_SYMBOL(nos_track_stats);
+
+static struct nos_user_track nos_user_tracks[NOS_USER_TRACK_MAX];
+static struct nos_flow_track nos_flow_tracks[NOS_FLOW_TRACK_MAX];
+
+static struct nos_mempool nos_user_track_pool;
+static struct nos_mempool nos_flow_track_pool;
+
+static struct hlist_head nos_user_track_hash[NOS_USER_TRACK_HASH_SIZE];
+static spinlock_t nos_user_track_hash_lock;
+
+static atomic_t nos_user_magic = ATOMIC_INIT(0);
+static atomic_t nos_flow_magic = ATOMIC_INIT(0);
+
+static struct nos_user_info *nos_user_info_base;
+static struct nos_flow_info *nos_flow_info_base;
+
+static struct {
+	struct list_head list;
+	spinlock_t lock;
+} nos_track_events;
+
+
+static struct nos_user_info *
+nos_user_info_init(struct nos_user_track *ut)
+{
+	int32_t user_id = ut - nos_user_tracks;
+	struct nos_user_info *ui = nos_user_info_base + user_id;
+
+	ui->id = user_id;
+	ui->ip = ut->ip;
+	ui->refcnt = 1;
+
+	memset(ui->data, 0, sizeof(ui->data));
+
+	smp_wmb();
+
+	ui->magic = ut->magic;
+
+	return ui;
+}
+
+static inline void
+nos_user_info_update_refcnt(struct nos_user_track *ut)
+{
+	int32_t user_id = ut - nos_user_tracks;
+	struct nos_user_info *ui = nos_user_info_base + user_id;
+	ui->refcnt = ut->refcnt;
+}
+
+static struct nos_flow_info *
+nos_flow_info_init(struct nos_flow_track *ft, struct nos_flow_tuple *tuple)
+{
+	int32_t flow_id = ft - nos_flow_tracks;
+	struct nos_flow_info *fi = nos_flow_info_base + flow_id;
+
+	fi->id = flow_id;
+	fi->usr_src_id = ft->usr_src - nos_user_tracks;
+	fi->usr_dst_id = ft->usr_dst - nos_user_tracks;
+	fi->tuple = *tuple;
+
+	memset(fi->data, 0, sizeof(fi->data));
+
+	smp_wmb();
+
+	fi->magic = ft->magic;
+
+	return fi;
+}
+
+static struct nos_user_track *
+nos_user_track_get(uint32_t ip)
+{
+	struct nos_user_track *user;
+	struct hlist_head *slot;
+	uint32_t slot_index;
+
+	slot_index = ip % NOS_USER_TRACK_HASH_SIZE;
+
+	spin_lock_bh(&nos_user_track_hash_lock);
+
+	slot = &nos_user_track_hash[slot_index];
+
+	hlist_for_each_entry(user, slot, hash_node) {
+		if (user->ip == ip) {
+			spin_lock_bh(&user->lock);
+			if (user->refcnt == 0) {
+				spin_unlock_bh(&user->lock);
+				break;
+			}
+			++user->refcnt;
+			nos_user_info_update_refcnt(user);
+			spin_unlock_bh(&user->lock);
+			goto out;
+		}
+	}
+
+	user = nos_mempool_get(&nos_user_track_pool);
+	if (user == NULL) {
+		goto out;
+	}
+
+	user->ip = ip;
+	user->magic = atomic_add_return(2, &nos_user_magic);
+	spin_lock_init(&user->lock);
+	user->refcnt = 1;
+	hlist_add_head(&user->hash_node, slot);
+	nos_user_info_init(user);
+
+	user->tbq = NULL;
+
+#if 0
+	printk("[nos_track] ADD USER: %pI4h\t(%6d / %6d)\n",
+			&ip, nos_user_track_pool.nr_used, nos_user_track_pool.nr_free);
+#endif
+
+out:
+	spin_unlock_bh(&nos_user_track_hash_lock);
+	return user;
+}
+
+static void
+nos_user_track_put(struct nos_user_track *user)
+{
+	struct nos_track_event *ev;
+	int32_t refcnt;
+
+	BUG_ON(user == NULL);
+
+	spin_lock_bh(&user->lock);
+	refcnt = --user->refcnt;
+	nos_user_info_update_refcnt(user);
+	spin_unlock_bh(&user->lock);
+
+	BUG_ON(refcnt < 0);
+
+	if (refcnt != 0)
+		return;
+
+	spin_lock_bh(&nos_track_events.lock);
+	list_for_each_entry(ev, &nos_track_events.list, list) {
+		ev->on_user_free(user);
+	}
+	spin_unlock_bh(&nos_track_events.lock);
+
+	BUG_ON(user->tbq != NULL);
+
+	// set delete mark
+	nos_user_info_base[user - nos_user_tracks].magic = user->magic | 1U;
+
+	spin_lock_bh(&nos_user_track_hash_lock);
+	hlist_del(&user->hash_node);
+	spin_unlock_bh(&nos_user_track_hash_lock);
+#if 0
+	printk("[nos_track] DEL: %pI4h\t(%6d / %6d)\n",
+			&user->ip, nos_user_track_pool.nr_used - 1, nos_user_track_pool.nr_free + 1);
+#endif
+	nos_mempool_put(&nos_user_track_pool, user);	
+}
+
+static void
+nos_track_check(struct nos_track *track)
+{
+	struct nos_flow_info *fi = track->flow;
+	struct nos_user_info *ui_src = track->usr_src;
+	struct nos_user_info *ui_dst = track->usr_dst;
+	uint32_t usr_src_id = ui_src - nos_user_info_base;
+	uint32_t usr_dst_id = ui_dst - nos_user_info_base;
+
+	if (usr_src_id >= NOS_USER_TRACK_MAX || usr_src_id != fi->usr_src_id) {
+		pr_warn_ratelimited("nos_flow_info error: %d, %d\n", usr_src_id, fi->usr_src_id);
+	}
+
+	if (usr_dst_id >= NOS_USER_TRACK_MAX || usr_dst_id != fi->usr_dst_id) {
+		pr_warn_ratelimited("nos_flow_info error: %d, %d\n", usr_dst_id, fi->usr_dst_id);
+	}
+}
+
+int
+nos_track_alloc(struct nos_track *track, struct nos_flow_tuple *tuple)
+{
+	struct nos_flow_track *flow = NULL;
+	struct nos_user_track *usr_src = NULL;
+	struct nos_user_track *usr_dst = NULL;
+
+	if (tuple->inface == NOS_FLOW_DIR_UNKNOWN)
+		goto fail;
+
+	flow = nos_mempool_get(&nos_flow_track_pool);
+	if (flow == NULL)
+		goto fail;
+
+	usr_src = nos_user_track_get(tuple->ip_src);
+	usr_dst = nos_user_track_get(tuple->ip_dst);
+
+	if (usr_src == NULL || usr_dst == NULL)
+		goto fail;
+
+	if (tuple->inface == NOS_FLOW_DIR_LAN2WAN) {
+		flow->usr_src = usr_src;
+		flow->usr_dst = usr_dst;
+	} else {
+		flow->usr_src = usr_dst;
+		flow->usr_dst = usr_src;
+	}
+
+	flow->magic = atomic_add_return(2, &nos_flow_magic);
+
+	track->flow = nos_flow_info_init(flow, tuple);
+	track->usr_src = &nos_user_info_base[track->flow->usr_src_id];
+	track->usr_dst = &nos_user_info_base[track->flow->usr_dst_id];
+	atomic64_inc(&nos_track_stats->nr_flow_alloc);
+
+	memset(&track->tbq, 0, sizeof(track->tbq));
+
+	return 0;
+
+fail:
+	if (flow != NULL) {
+		if (usr_src != NULL)
+			nos_user_track_put(usr_src);
+		if (usr_dst != NULL)
+			nos_user_track_put(usr_dst);
+		nos_mempool_put(&nos_flow_track_pool, flow);
+	}
+	track->flow = NULL;
+	track->usr_src = NULL;
+	track->usr_dst = NULL;
+	return -1;
+}
+EXPORT_SYMBOL(nos_track_alloc);
+
+void
+nos_track_free(struct nos_track *track)
+{
+	struct nos_flow_track *flow;
+	struct nos_track_event *ev;
+	int flow_id;
+
+	if (track->flow == NULL) {
+		return;
+	}
+
+	flow_id = track->flow - nos_flow_info_base;
+	BUG_ON(flow_id < 0 || flow_id >= NOS_FLOW_TRACK_MAX);
+	
+	nos_track_check(track);
+
+	flow = &nos_flow_tracks[flow_id];
+
+	spin_lock_bh(&nos_track_events.lock);
+	list_for_each_entry(ev, &nos_track_events.list, list) {
+		ev->on_flow_free(&track->tbq);
+	}
+	spin_unlock_bh(&nos_track_events.lock);
+
+	track->flow->magic = flow->magic | 1U; // delete mark
+
+	nos_user_track_put(flow->usr_src);
+	nos_user_track_put(flow->usr_dst);	
+
+	nos_mempool_put(&nos_flow_track_pool, flow);
+
+	atomic64_inc(&nos_track_stats->nr_flow_free);
+}
+EXPORT_SYMBOL(nos_track_free);
+
+struct nos_user_track *
+nos_get_user_track(struct nos_track *track)
+{
+	int user_id;
+
+	BUG_ON(track->flow == NULL);
+	BUG_ON(track->usr_src == NULL);
+	BUG_ON(track->usr_dst == NULL);
+
+	user_id = track->usr_src - nos_user_info_base;
+	BUG_ON(user_id < 0 || user_id >= NOS_USER_TRACK_MAX);
+	return nos_user_tracks + user_id;
+}
+EXPORT_SYMBOL(nos_get_user_track);
+
+struct nos_flow_track *
+nos_get_flow_track(struct nos_track *track)
+{
+	int flow_id;
+
+	BUG_ON(track->flow == NULL);
+	BUG_ON(track->usr_src == NULL);
+	BUG_ON(track->usr_dst == NULL);
+
+	flow_id = track->flow - nos_flow_info_base;
+	BUG_ON(flow_id < 0 || flow_id >= NOS_FLOW_TRACK_MAX);
+	return nos_flow_tracks + flow_id;
+}
+EXPORT_SYMBOL(nos_get_flow_track);
+
+void nos_track_event_register(struct nos_track_event *ev)
+{
+	spin_lock_bh(&nos_track_events.lock);
+	list_add_tail(&ev->list, &nos_track_events.list);
+	spin_unlock_bh(&nos_track_events.lock);
+}
+EXPORT_SYMBOL(nos_track_event_register);
+
+void nos_track_event_unregister(struct nos_track_event *ev)
+{
+	spin_lock_bh(&nos_track_events.lock);
+	list_del(&ev->list);
+	spin_unlock_bh(&nos_track_events.lock);
+}
+EXPORT_SYMBOL(nos_track_event_unregister);
+
+int
+nos_track_init()
+{
+	int i;
+
+	extern struct resource nosmem_res;
+	nos_user_info_base = phys_to_virt(nosmem_res.start + (4 << 20));
+	nos_flow_info_base = (void *)(nos_user_info_base + NOS_USER_TRACK_MAX);
+	nos_track_stats = (void *)(nos_flow_info_base + NOS_FLOW_TRACK_MAX);
+
+	printk("nos_user_info_base: %p (phys: %lx)\n",
+			nos_user_info_base, virt_to_phys(nos_user_info_base));
+	printk("nos_flow_info_base: %p (phys: %lx)\n",
+			nos_flow_info_base, virt_to_phys(nos_flow_info_base));
+	printk("nos_track_stats: %p (phys: %lx)\n",
+			nos_track_stats, virt_to_phys(nos_track_stats));
+
+	if (virt_to_phys(nos_track_stats + 1) > nosmem_res.end) {
+		printk("nosmem_res oom: [%llu - %llu]\n", (uint64_t)nosmem_res.start, (uint64_t)nosmem_res.end);
+		return -1;
+	}
+
+	// delete mark: magic & 1 == 1
+	memset(nos_user_info_base, 0xAF, NOS_USER_TRACK_MAX * sizeof(struct nos_user_info));
+	memset(nos_flow_info_base, 0xBF, NOS_FLOW_TRACK_MAX * sizeof(struct nos_flow_info));
+
+	nos_mempool_init(&nos_user_track_pool, "nos_user_track", NOS_USER_TRACK_MAX);
+	for (i = 0; i < NOS_USER_TRACK_MAX; i++) {
+		nos_mempool_put(&nos_user_track_pool, &nos_user_tracks[i]);
+	}
+
+	nos_mempool_init(&nos_flow_track_pool, "nos_flow_track", NOS_FLOW_TRACK_MAX);
+	for (i = 0; i < NOS_FLOW_TRACK_MAX; i++) {
+		nos_mempool_put(&nos_flow_track_pool, &nos_flow_tracks[i]);
+	}
+
+	spin_lock_init(&nos_user_track_hash_lock);
+	for (i = 0; i < NOS_USER_TRACK_HASH_SIZE; i++) {
+		INIT_HLIST_HEAD(&nos_user_track_hash[i]);
+	}
+
+	INIT_LIST_HEAD(&nos_track_events.list);
+	spin_lock_init(&nos_track_events.lock);
+
+	printk("nos_track_init() OK [user size: %d, flow size: %d]\n",
+		   (int)sizeof(struct nos_user_info), (int)sizeof(struct nos_flow_info));
+
+	return 0;
+}
+EXPORT_SYMBOL(nos_track_init);
diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c
index c09d6c7..9fbdfc1 100644
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@ -120,6 +120,9 @@ EXPORT_SYMBOL_GPL(nf_conntrack_htable_size);
 unsigned int nf_conntrack_max __read_mostly;
 EXPORT_SYMBOL_GPL(nf_conntrack_max);
 
+unsigned int nf_conntrack_mode __read_mostly;
+EXPORT_SYMBOL_GPL(nf_conntrack_mode);
+
 DEFINE_PER_CPU(struct nf_conn, nf_conntrack_untracked);
 EXPORT_PER_CPU_SYMBOL(nf_conntrack_untracked);
 
@@ -887,6 +890,9 @@ void nf_conntrack_free(struct nf_conn *ct)
 {
 	struct net *net = nf_ct_net(ct);
 
+	/* roy: nos node track */
+	nos_track_free(&ct->nos_track);
+
 	/* A freed object has refcnt == 0, that's
 	 * the golden rule for SLAB_DESTROY_BY_RCU
 	 */
@@ -920,6 +926,8 @@ init_conntrack(struct net *net, struct nf_conn *tmpl,
 	struct nf_conn_timeout *timeout_ext;
 	struct nf_conntrack_zone tmp;
 	unsigned int *timeouts;
+	/* roy: for traffic control */
+	struct nos_flow_tuple nos_flow_tuple;
 
 	if (!nf_ct_invert_tuple(&repl_tuple, tuple, l3proto, l4proto)) {
 		pr_debug("Can't invert tuple.\n");
@@ -943,6 +951,32 @@ init_conntrack(struct net *net, struct nf_conn *tmpl,
 	else
 		timeouts = l4proto->get_timeouts(net);
 
+	/* roy: nos track init nodes */
+	nos_flow_tuple.ip_src = __be32_to_cpu(tuple->src.u3.ip);
+	nos_flow_tuple.ip_dst = __be32_to_cpu(tuple->dst.u3.ip);
+	nos_flow_tuple.port_src = __be16_to_cpu(tuple->src.u.all);
+	nos_flow_tuple.port_dst = __be16_to_cpu(tuple->dst.u.all);
+	nos_flow_tuple.proto = tuple->dst.protonum;
+	if (skb->dev) {
+		const struct net_device *dev_in;
+		if(nf_ct_net_mode() == UGW_NET_MODE_BRIDGE) {
+			dev_in = skb->nf_bridge ? skb->nf_bridge->physindev : skb->dev;
+		} else {
+			dev_in = skb->dev;
+		}
+		if (strncmp(dev_in->name, "br", 2) == 0 ||
+			strcmp(dev_in->name, "eth0.5") != 0) {
+			//brX,eth0.1-4: lan interface.
+			nos_flow_tuple.inface = NOS_FLOW_DIR_LAN2WAN;
+		} else {
+			//bridge: eth0.5, router: eth0.2-5: WAN
+			nos_flow_tuple.inface = NOS_FLOW_DIR_WAN2LAN;
+		}
+	} else {
+		nos_flow_tuple.inface = NOS_FLOW_DIR_UNKNOWN;
+	}
+	nos_track_alloc(&ct->nos_track, &nos_flow_tuple);
+
 	if (!l4proto->new(ct, skb, dataoff, timeouts)) {
 		nf_conntrack_free(ct);
 		pr_debug("init conntrack: can't track with proto module\n");
@@ -1629,6 +1663,12 @@ int nf_conntrack_init_start(void)
 	int max_factor = 8;
 	int i, ret, cpu;
 
+	ret = nos_track_init();
+	if (ret < 0) {
+		printk("%s: nos track init err: %d\n", __FUNCTION__, ret);
+		return ret;
+	}
+
 	for (i = 0; i < CONNTRACK_LOCKS; i++)
 		spin_lock_init(&nf_conntrack_locks[i]);
 
diff --git a/net/netfilter/nf_conntrack_standalone.c b/net/netfilter/nf_conntrack_standalone.c
index 9c78440..50521d8 100644
--- a/net/netfilter/nf_conntrack_standalone.c
+++ b/net/netfilter/nf_conntrack_standalone.c
@@ -536,6 +536,13 @@ static struct ctl_table nf_ct_sysctl_table[] = {
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec,
 	},
+	{
+		.procname	= "nf_conntrack_mode",
+		.data		= &nf_conntrack_mode,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
 	{ }
 };
 
-- 
1.9.1

